<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IsisReader: contrib/malete/mlt/core.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>contrib/malete/mlt/core.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">        The Malete project - the Z39.2/Z39.50 database framework of OpenIsis.</span>
<a name="l00003"></a>00003 <span class="comment">        Version 0.9.x (patchlevel see file Version)</span>
<a name="l00004"></a>00004 <span class="comment">        Copyright (C) 2001-2003 by Erik Grziwotz, erik@openisis.org</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">        This library is free software; you can redistribute it and/or</span>
<a name="l00007"></a>00007 <span class="comment">        modify it under the terms of the GNU Lesser General Public</span>
<a name="l00008"></a>00008 <span class="comment">        License as published by the Free Software Foundation; either</span>
<a name="l00009"></a>00009 <span class="comment">        version 2.1 of the License, or (at your option) any later version.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">        This library is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment">        but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment">        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l00014"></a>00014 <span class="comment">        See the GNU Lesser General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">        You should have received a copy of the GNU Lesser General Public</span>
<a name="l00017"></a>00017 <span class="comment">        License along with this library; if not, write to the Free Software</span>
<a name="l00018"></a>00018 <span class="comment">        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">        see README for more information</span>
<a name="l00021"></a>00021 <span class="comment">EOH */</span>
<a name="l00022"></a>00022 <span class="preprocessor">#ifndef CORE_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;string.h&gt;</span> <span class="comment">/* various str* and mem* */</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment">        $Id: core.h,v 1.4 2005/05/29 10:30:36 kripke Exp $</span>
<a name="l00028"></a>00028 <span class="comment">        full interface of the Malete core</span>
<a name="l00029"></a>00029 <span class="comment">*/</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#define CORE_VERSION &quot;1.0.3&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">/* ****************************************************************** */</span>
<a name="l00036"></a>00036 <span class="comment">/*                                                                    */</span>
<a name="l00037"></a>00037 <span class="comment">/* COMPILER FEATURES                                                  */</span>
<a name="l00038"></a>00038 <span class="comment">/*                                                                    */</span>
<a name="l00039"></a>00039 <span class="comment">/* ****************************************************************** */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef __STDC__ </span><span class="comment">/* defined by ISO C */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#error &quot;need ANSI/ISO C compiler&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="comment">/* &quot;cpp -dM &lt;/dev/null&quot; lists nonstandard machine and OS macros */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/* optimizing */</span>
<a name="l00047"></a>00047 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#       define OPT_INLINE __inline__ </span><span class="comment">/* OPT_INLINE type func () */</span>
<a name="l00049"></a>00049 <span class="preprocessor">#else</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#       define OPT_INLINE</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#if defined( __i386__ ) &amp;&amp; defined( __GNUC__ )</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="comment">/* called function pops args; makes most functions slightly faster */</span>
<a name="l00054"></a>00054 <span class="comment">/* type OPT_STDCALL func () on both declaration and definition */</span>
<a name="l00055"></a>00055 <span class="preprocessor">#       define OPT_STDCALL __attribute__((stdcall))</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#       define OPT_STDCALL</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#if defined( __i386__ ) &amp;&amp; defined( __GNUC__ ) &amp;&amp; defined(NDEBUG)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="comment">/* more aggressive: up to 3 args in registers, fails with -pg */</span>
<a name="l00061"></a>00061 <span class="comment">/* type OPT_REGPARM func () in declaration is sufficient */</span>
<a name="l00062"></a>00062 <span class="comment">/* also using in definition allows fallback to stdcall */</span>
<a name="l00063"></a>00063 <span class="preprocessor">#       define OPT_REGPARM __attribute__((regparm(3)))</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#       define OPT_REGPARM OPT_STDCALL</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 <span class="comment">/* CPU features */</span>
<a name="l00069"></a>00069 <span class="preprocessor">#if defined( __sparc__ ) || defined( __ppc__ )</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#       define CPU_BIG_ENDIAN</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#if defined( __sparc__ )</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#       define CPU_NEED_ALIGN</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="comment">/* max bits of PAGE_SIZE; min is always 12 */</span>
<a name="l00076"></a>00076 <span class="comment">/* grep -r &apos;fine PAGE_SHIFT&apos; /usr/src/linux/include/asm-* : 12..16 */</span>
<a name="l00077"></a>00077 <span class="preprocessor">#if defined( __ia64__ )</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#       define CPU_PAGE_SHIFT 16</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#elif defined( __arm__ )</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#       define CPU_PAGE_SHIFT 15</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#elif defined( __i386__ ) || defined( __ppc__ )</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#       define CPU_PAGE_SHIFT 12 </span><span class="comment">/* there are more not exceeding 12 bits */</span>
<a name="l00083"></a>00083 <span class="preprocessor">#else </span><span class="comment">/* however 13 bits is not too much waste */</span>
<a name="l00084"></a>00084 <span class="preprocessor">#       define CPU_PAGE_SHIFT 13 </span><span class="comment">/* sparc, sparc64, alpha, m68k, cris */</span>
<a name="l00085"></a>00085 <span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 <span class="comment">/* 64 bit integer */</span>
<a name="l00088"></a>00088 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#       define LOLO_BUILTIN long long</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#       define LOLO( v ) v##LL</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#       define LULU( v ) v##ULL</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#elif defined( _MSC_VER ) || defined( __BORLANDC__ )</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#       define LOLO_BUILTIN __int64</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#       define LOLO( v ) v </span><span class="comment">/* is there some special suffix ??? */</span>
<a name="l00095"></a>00095 <span class="preprocessor">#       define LULU( v ) v</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#elif 0xFFFFFFFFL != ~0L </span><span class="comment">/* 64 bit compiler ? */</span>
<a name="l00097"></a>00097 <span class="preprocessor">#       define LOLO_BUILTIN long</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#       define LOLO( v ) v##L</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#       define LULU( v ) v##UL</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#       error &quot;please use a compiler providing a 64 bit integer type. thanks.&quot;</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="keyword">typedef</span> LOLO_BUILTIN lolo;
<a name="l00104"></a>00104 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> LOLO_BUILTIN lulu;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">/* ****************************************************************** */</span>
<a name="l00109"></a>00109 <span class="comment">/*                                                                    */</span>
<a name="l00110"></a>00110 <span class="comment">/* BUILD FEATURES                                                     */</span>
<a name="l00111"></a>00111 <span class="comment">/*                                                                    */</span>
<a name="l00112"></a>00112 <span class="comment">/* ****************************************************************** */</span>
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">/* do not support the ENV_SHARED mode */</span>
<a name="l00115"></a>00115 <span class="preprocessor">#if defined(BUILD_SHMODE) </span><span class="comment">/* is broken */</span>
<a name="l00116"></a>00116 <span class="preprocessor">#       undef BUILD_SHMODE</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">/* ****************************************************************** */</span>
<a name="l00122"></a>00122 <span class="comment">/*                                                                    */</span>
<a name="l00123"></a>00123 <span class="comment">/* DATA STRUCTURES AND UTILITIES                                      */</span>
<a name="l00124"></a>00124 <span class="comment">/*                                                                    */</span>
<a name="l00125"></a>00125 <span class="comment">/* ****************************************************************** */</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">/* some characters */</span>
<a name="l00128"></a>00128 <span class="preprocessor">#define TAB 9 </span><span class="comment">/* horizontal, that is */</span>
<a name="l00129"></a>00129 <span class="preprocessor">#define LF 10 </span><span class="comment">/* LineFeed a.k.a. newline - &apos;\n&apos; isn&apos;t really well defined */</span>
<a name="l00130"></a>00130 <span class="preprocessor">#define VT 11 </span><span class="comment">/* vertical, used as newline replacement */</span>
<a name="l00131"></a>00131 <span class="preprocessor">#define CR 13 </span><span class="comment">/* for windoze, telnet and the like */</span>
<a name="l00132"></a>00132 
<a name="l00137"></a>00137 <span class="keyword">extern</span> <span class="keywordtype">int</span> a2i ( <span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> l );
<a name="l00142"></a>00142 <span class="keyword">extern</span> <span class="keywordtype">int</span> a2il ( <span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> l, <span class="keywordtype">int</span> *res );
<a name="l00146"></a>00146 <span class="keyword">extern</span> <span class="keywordtype">int</span> a2id ( <span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> l, <span class="keywordtype">int</span> dflt );
<a name="l00151"></a>00151 <span class="keyword">extern</span> <span class="keywordtype">int</span> i2a ( <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> i );
<a name="l00152"></a>00152 <span class="keyword">extern</span> <span class="keywordtype">int</span> u2a ( <span class="keywordtype">char</span> *p, <span class="keywordtype">unsigned</span> u );
<a name="l00153"></a>00153 <span class="comment">/* print exactly n digits, do not add 0 byte */</span>
<a name="l00154"></a>00154 <span class="keyword">extern</span> <span class="keywordtype">void</span> u2a0 ( <span class="keywordtype">char</span> *p, <span class="keywordtype">unsigned</span> u, <span class="keywordtype">unsigned</span> n );
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> b36dig[36]; <span class="comment">/* &apos;0&apos;..&apos;9&apos;, &apos;a&apos;..&apos;z&apos; */</span>
<a name="l00157"></a>00157 <span class="comment">/* 0..35 &apos;0&apos;..&apos;9&apos;, &apos;a&apos;..&apos;z&apos; and &apos;A&apos;..&apos;Z&apos;, 36 else */</span>
<a name="l00158"></a>00158 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> b36val[256];
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lat1up[256]; <span class="comment">/* latin 1 uppercase */</span>
<a name="l00161"></a>00161 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lat1ct[256]; <span class="comment">/* latin 1 ctype */</span>
<a name="l00162"></a>00162 <span class="keyword">enum</span> { <span class="comment">/* character type bits */</span>
<a name="l00163"></a>00163         CT_WHITE = 0x01, <span class="comment">/* all &lt;= &apos; &apos; */</span>
<a name="l00164"></a>00164         CT_DIGIT = 0x02, <span class="comment">/* 0..9 */</span>
<a name="l00165"></a>00165         CT_ALPHA = 0x04, <span class="comment">/* &apos;A&apos;..&apos;Z&apos;,&apos;a&apos;..&apos;z&apos; */</span>
<a name="l00166"></a>00166         CT_IDENT = 0x08, <span class="comment">/* digits,alphas,underscore */</span>
<a name="l00167"></a>00167         CT_SPECL = 0x10, <span class="comment">/* all other ASCIIs */</span>
<a name="l00168"></a>00168         CT_LATIN = 0x20  <span class="comment">/* ident + non ASCII Latin1 alphas */</span>
<a name="l00169"></a>00169 };
<a name="l00170"></a>00170 <span class="keyword">enum</span> { <span class="comment">/* character type values */</span>
<a name="l00171"></a>00171         CT_W = CT_WHITE,
<a name="l00172"></a>00172         CT_D = CT_DIGIT|CT_IDENT|CT_LATIN,
<a name="l00173"></a>00173         CT_A = CT_ALPHA|CT_IDENT|CT_LATIN,
<a name="l00174"></a>00174         CT_I = CT_IDENT|CT_LATIN,
<a name="l00175"></a>00175         CT_S = CT_SPECL,
<a name="l00176"></a>00176         CT_L = CT_LATIN,
<a name="l00177"></a>00177         CT_N = 0 <span class="comment">/* other C1 control or symbol */</span>
<a name="l00178"></a>00178 };
<a name="l00179"></a>00179 <span class="preprocessor">#define CT_IS(type, c) (CT_##type == lat1ct[(unsigned char)(c)])</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#define CT_HAS(flg, c) (CT_##flg &amp; lat1ct[(unsigned char)(c)])</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00182"></a>00182 
<a name="l00184"></a>00184 <span class="keyword">extern</span> <span class="keywordtype">void</span> mTr ( <span class="keywordtype">char</span> *bytes, <span class="keywordtype">char</span> from, <span class="keywordtype">char</span> to, <span class="keywordtype">int</span> len );
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 
<a name="l00187"></a><a class="code" href="structFld.html">00187</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structFld.html">Fld</a> {
<a name="l00188"></a>00188         <span class="keywordtype">int</span>      tag;
<a name="l00189"></a>00189         <span class="keywordtype">unsigned</span> len; <span class="comment">/* must use at most 31 bits, highest is temporarily abused */</span>
<a name="l00190"></a>00190         <span class="keywordtype">char</span>    *val; <span class="comment">/* not necessarily 0 terminated */</span>
<a name="l00191"></a>00191 } <a class="code" href="structFld.html">Fld</a>;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="comment">/*</span>
<a name="l00194"></a>00194 <span class="comment">        v (value) functions on single field</span>
<a name="l00195"></a>00195 <span class="comment">*/</span>
<a name="l00196"></a>00196 <span class="preprocessor">#define V2I( f ) a2i( (f)-&gt;val, (f)-&gt;len )</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>
<a name="l00198"></a>00198 <span class="comment">/* field has primary value key length l */</span>
<a name="l00199"></a>00199 <span class="preprocessor">#define VKEY( f, k, l ) ( \</span>
<a name="l00200"></a>00200 <span class="preprocessor">        (f)-&gt;len &gt;= (l) &amp;&amp; !memcmp( (f)-&gt;val, k, l ) \</span>
<a name="l00201"></a>00201 <span class="preprocessor">        &amp;&amp; ((f)-&gt;len == (l) || TAB == (f)-&gt;val[(l)]) \</span>
<a name="l00202"></a>00202 <span class="preprocessor">)</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>
<a name="l00204"></a>00204 <span class="comment">/* dup a field as 0-terminated string */</span>
<a name="l00205"></a>00205 <span class="preprocessor">#define VDUPZ( f ) ((char*)mDupz((f)-&gt;val, (f)-&gt;len))</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
<a name="l00207"></a>00207 <span class="comment">/*</span>
<a name="l00208"></a>00208 <span class="comment">        snip tab-separated subfields from value,</span>
<a name="l00209"></a>00209 <span class="comment">        setting tag to the subfield identifier and len/val to the contents.</span>
<a name="l00210"></a>00210 <span class="comment">        if opt is not 0, it lists the options wanted (* for the primary).</span>
<a name="l00211"></a>00211 <span class="comment">        dst-&gt;val should be 0-initialized;</span>
<a name="l00212"></a>00212 <span class="comment">        if it&apos;s greater than src-&gt;val, search starts at dst-&gt;val+dst-&gt;len,</span>
<a name="l00213"></a>00213 <span class="comment">        @return 0 if not found, else 1+dst-&gt;len</span>
<a name="l00214"></a>00214 <span class="comment">*/</span>
<a name="l00215"></a>00215 <span class="keyword">extern</span> <span class="keywordtype">int</span> vGet ( <a class="code" href="structFld.html">Fld</a> *dst, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *src, <span class="keyword">const</span> <span class="keywordtype">char</span> *opt );
<a name="l00216"></a>00216 <span class="comment">/*</span>
<a name="l00217"></a>00217 <span class="comment">        access to the primary value never fails, if initialized, so return len</span>
<a name="l00218"></a>00218 <span class="comment">*/</span>
<a name="l00219"></a>00219 <span class="preprocessor">#define VPRI( dst, src ) ((dst)-&gt;val = 0, vGet(dst, src, 0), (dst)-&gt;len)</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#define VEQZ( f, str ) (!strncmp((f)-&gt;val,str,(f)-&gt;len) &amp;&amp; !str[(f)-&gt;len])</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>
<a name="l00228"></a>00228 <span class="comment">/* sign(a - b) */</span>
<a name="l00229"></a>00229 <span class="keyword">extern</span> <span class="keywordtype">int</span> vCmp ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *a, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *b );
<a name="l00230"></a>00230 <span class="comment">/* a &gt; b */</span>
<a name="l00231"></a>00231 <span class="keyword">extern</span> <span class="keywordtype">int</span> vGt ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *a, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *b );
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="comment">/* comparision function type for rSort */</span>
<a name="l00234"></a>00234 <span class="keyword">typedef</span> <span class="keywordtype">int</span> VGt ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *a, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *b );
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="comment">/*</span>
<a name="l00238"></a>00238 <span class="comment">        r (record) functions on an array of fields</span>
<a name="l00239"></a>00239 <span class="comment">        they expect the tag of the first field to be the negative number of fields.</span>
<a name="l00240"></a>00240 <span class="comment">        The value of the first field (&quot;header&quot;) may contain various meta info.</span>
<a name="l00241"></a>00241 <span class="comment">        For lists representing database &quot;records&quot;,</span>
<a name="l00242"></a>00242 <span class="comment">        the canonical format is [no[@pos]][&lt;TAB&gt;leader].</span>
<a name="l00243"></a>00243 <span class="comment">        Leader can be used e.g. to hold a Z39.2 leader as used by MARC.</span>
<a name="l00244"></a>00244 <span class="comment">        Other (protocol) lists should start with some type identifier.</span>
<a name="l00245"></a>00245 <span class="comment"></span>
<a name="l00246"></a>00246 <span class="comment">        it&apos;s a matter of taste whether you like and use this typedef.</span>
<a name="l00247"></a>00247 <span class="comment">        as it&apos;s not going to be changed but only here to clarify the intend,</span>
<a name="l00248"></a>00248 <span class="comment">        the core functions do not use it.</span>
<a name="l00249"></a>00249 <span class="comment">*/</span>
<a name="l00250"></a>00250 <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *<a class="code" href="structFld.html">Rec</a>;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="preprocessor">#define RLEN( r )  (-(r)-&gt;tag)</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span><span class="preprocessor">#define REND( r )  ((r)-(r)-&gt;tag)</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span><span class="preprocessor">#define RLAST( r ) (REND(r)-1)</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>
<a name="l00256"></a>00256 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> rSiz ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *r );
<a name="l00257"></a>00257 
<a name="l00265"></a>00265 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *rGet ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *r, <span class="keywordtype">int</span> tag, <span class="keywordtype">int</span> *pos );
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">/*</span>
<a name="l00268"></a>00268 <span class="comment">        get field with given tag and primary value or empty pv</span>
<a name="l00269"></a>00269 <span class="comment">*/</span>
<a name="l00270"></a>00270 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *rKey ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *r, <span class="keywordtype">int</span> tag, <span class="keyword">const</span> <span class="keywordtype">char</span> *key );
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment">/*</span>
<a name="l00273"></a>00273 <span class="comment">        create a new const rec in a contigous mAlloced piece of mem</span>
<a name="l00274"></a>00274 <span class="comment">        if siz is 0, rSiz() is used</span>
<a name="l00275"></a>00275 <span class="comment">*/</span>
<a name="l00276"></a>00276 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *rDup ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *src, <span class="keywordtype">unsigned</span> siz );
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00286"></a>00286 <span class="keyword">extern</span> <span class="keywordtype">int</span> rSer ( <span class="keywordtype">char</span> *buf, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *rec );
<a name="l00287"></a>00287 
<a name="l00293"></a>00293 <span class="keyword">extern</span> <span class="keywordtype">void</span> rSort ( <a class="code" href="structFld.html">Fld</a> *rec, VGt *gt );
<a name="l00294"></a>00294 <span class="keyword">extern</span> <span class="keywordtype">void</span> rSortTag ( <a class="code" href="structFld.html">Fld</a> *rec );
<a name="l00295"></a>00295 <span class="keyword">extern</span> <span class="keywordtype">void</span> rSortVal ( <a class="code" href="structFld.html">Fld</a> *rec ); <span class="comment">/* == rSort(vGt) */</span>
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="preprocessor">#define DEFBLKLEN 8000 </span><span class="comment">/* default buffer block length */</span>
<a name="l00299"></a>00299 <span class="preprocessor">#define DEFFIELDS 40 </span><span class="comment">/* default number of fields */</span>
<a name="l00300"></a>00300 
<a name="l00301"></a><a class="code" href="structLBlk.html">00301</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structLBlk.html">LBlk</a> { <span class="comment">/* chained buffer block */</span>
<a name="l00302"></a>00302         <span class="keyword">struct </span><a class="code" href="structLBlk.html">LBlk</a> *nxt;
<a name="l00303"></a>00303         <span class="keywordtype">unsigned</span>     siz;
<a name="l00304"></a>00304         <span class="keywordtype">char</span>         byt[DEFBLKLEN]; <span class="comment">/* actual len may vary */</span>
<a name="l00305"></a>00305 } <a class="code" href="structLBlk.html">LBlk</a>;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="comment">/*</span>
<a name="l00309"></a>00309 <span class="comment">        A full-fledged, modifiable list.</span>
<a name="l00310"></a>00310 <span class="comment">*/</span>
<a name="l00311"></a><a class="code" href="structList.html">00311</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structList.html">List</a> {
<a name="l00312"></a>00312         <a class="code" href="structFld.html">Fld</a>      *fld; <span class="comment">/* fields list, initially fl0 */</span>
<a name="l00313"></a>00313         <span class="keywordtype">unsigned</span>  fav; <span class="comment">/* fields available at end of *fld buffer */</span>
<a name="l00314"></a>00314         <span class="keywordtype">int</span>       siz; <span class="comment">/* used secondary buffer size minus holes (add buf-blk.byt) */</span>
<a name="l00315"></a>00315         <span class="keywordtype">char</span>     *buf; <span class="comment">/* pointing into blk-&gt;byt */</span>
<a name="l00316"></a>00316         <span class="keywordtype">char</span>     *end; <span class="comment">/* of blk-&gt;byt */</span>
<a name="l00317"></a>00317         <a class="code" href="structLBlk.html">LBlk</a>     *blk; <span class="comment">/* buffer chain, initially bl0 */</span>
<a name="l00318"></a>00318         <span class="keywordtype">char</span>     *bok; <span class="comment">/* if == buf, buffers contain the serialization */</span>
<a name="l00319"></a>00319         <a class="code" href="structFld.html">Fld</a>       fl0[DEFFIELDS];
<a name="l00320"></a>00320         <a class="code" href="structLBlk.html">LBlk</a>      bl0;
<a name="l00321"></a>00321 } <a class="code" href="structList.html">List</a>;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="preprocessor">#define LLEN( l )  RLEN((l)-&gt;fld)</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="preprocessor">#define LEND( l )  REND((l)-&gt;fld)</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span><span class="preprocessor">#define LLAST( l ) RLAST((l)-&gt;fld)</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="comment">/*</span>
<a name="l00330"></a>00330 <span class="comment">        initialize list and set header.</span>
<a name="l00331"></a>00331 <span class="comment">        if fmt is 0, no header is printed, and the list left empty.</span>
<a name="l00332"></a>00332 <span class="comment">        (i.e. the first field added will become the header).</span>
<a name="l00333"></a>00333 <span class="comment">        @return l</span>
<a name="l00334"></a>00334 <span class="comment">*/</span>
<a name="l00335"></a>00335 <span class="keyword">extern</span> <a class="code" href="structList.html">List</a> *lInit ( <a class="code" href="structList.html">List</a> *l, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ... );
<a name="l00336"></a>00336 <span class="comment">/*</span>
<a name="l00337"></a>00337 <span class="comment">        completely clear all fields and buffers.</span>
<a name="l00338"></a>00338 <span class="comment">*/</span>
<a name="l00339"></a>00339 <span class="keyword">extern</span> <a class="code" href="structList.html">List</a> *lClr ( <a class="code" href="structList.html">List</a> *l );
<a name="l00340"></a>00340 <span class="comment">/*</span>
<a name="l00341"></a>00341 <span class="comment">        clear all fields and buffers, but keep the header.</span>
<a name="l00342"></a>00342 <span class="comment">*/</span>
<a name="l00343"></a>00343 <span class="keyword">extern</span> <a class="code" href="structList.html">List</a> *lReset ( <a class="code" href="structList.html">List</a> *l );
<a name="l00344"></a>00344 <span class="comment">/*</span>
<a name="l00345"></a>00345 <span class="comment">        clear all fields and buffers, keep nothing</span>
<a name="l00346"></a>00346 <span class="comment">*/</span>
<a name="l00347"></a>00347 <span class="keyword">extern</span> <span class="keywordtype">void</span> OPT_STDCALL lFini ( <a class="code" href="structList.html">List</a> *l );
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="comment">/*</span>
<a name="l00350"></a>00350 <span class="comment">        increase available space.</span>
<a name="l00351"></a>00351 <span class="comment">        If buffer has a flusher, call it.</span>
<a name="l00352"></a>00352 <span class="comment">        fields -1 means we want to append (keep last field contigous, do NOT flush).</span>
<a name="l00353"></a>00353 <span class="comment">        fields &gt;0 means reserve at least mode fields.</span>
<a name="l00354"></a>00354 <span class="comment">*/</span>
<a name="l00355"></a>00355 <span class="keyword">extern</span> <span class="keywordtype">int</span> OPT_REGPARM lExtend ( <a class="code" href="structList.html">List</a> *l, <span class="keywordtype">unsigned</span> need, <span class="keywordtype">int</span> fields );
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="comment">/* bytes available at buf */</span>
<a name="l00360"></a>00360 <span class="preprocessor">#define LAVL( l ) ((unsigned)((l)-&gt;end - (l)-&gt;buf))</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span><span class="preprocessor">#define LSIZ( l ) ((unsigned)((l)-&gt;buf - (l)-&gt;blk-&gt;byt + (l)-&gt;siz))</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>
<a name="l00363"></a>00363 <span class="comment">/*</span>
<a name="l00364"></a>00364 <span class="comment">        fragment used to start a new field with tag t.</span>
<a name="l00365"></a>00365 <span class="comment">        If the list was empty, the field will become the header,</span>
<a name="l00366"></a>00366 <span class="comment">        ignoring the tag.</span>
<a name="l00367"></a>00367 <span class="comment">*/</span>
<a name="l00368"></a>00368 <span class="preprocessor">#define LDEFNEWF( l, t ) \</span>
<a name="l00369"></a>00369 <span class="preprocessor">        int __i = (l)-&gt;fld-&gt;tag; \</span>
<a name="l00370"></a>00370 <span class="preprocessor">        Fld *__f = (l)-&gt;fld - __i--; \</span>
<a name="l00371"></a>00371 <span class="preprocessor">        __f-&gt;tag = t; \</span>
<a name="l00372"></a>00372 <span class="preprocessor">        (l)-&gt;fld-&gt;tag = __i;</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>
<a name="l00374"></a>00374 <span class="comment">/* add field tag t reserving n bytes space */</span>
<a name="l00375"></a>00375 <span class="preprocessor">#define LNEWF( l, t, n ) do { \</span>
<a name="l00376"></a>00376 <span class="preprocessor">        if ( ((l)-&gt;fav &amp;&amp; LAVL(l) &gt;= n) || lExtend( l, n, 1 ) ) { \</span>
<a name="l00377"></a>00377 <span class="preprocessor">                LDEFNEWF( l, t ) \</span>
<a name="l00378"></a>00378 <span class="preprocessor">                __f-&gt;val = (l)-&gt;buf; \</span>
<a name="l00379"></a>00379 <span class="preprocessor">                __f-&gt;len = 0; \</span>
<a name="l00380"></a>00380 <span class="preprocessor">                (l)-&gt;fav --; \</span>
<a name="l00381"></a>00381 <span class="preprocessor">        } } while(0)</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span>
<a name="l00383"></a>00383 <span class="comment">/* add field tag t using n bytes prefilled space</span>
<a name="l00384"></a>00384 <span class="comment">        must be preextended for one field</span>
<a name="l00385"></a>00385 <span class="comment">*/</span>
<a name="l00386"></a>00386 <span class="preprocessor">#define LPREF( l, t, n ) do { \</span>
<a name="l00387"></a>00387 <span class="preprocessor">        if ( (l)-&gt;fav ) { \</span>
<a name="l00388"></a>00388 <span class="preprocessor">                LDEFNEWF( l, t ) \</span>
<a name="l00389"></a>00389 <span class="preprocessor">                __f-&gt;val = (l)-&gt;buf; \</span>
<a name="l00390"></a>00390 <span class="preprocessor">                __f-&gt;len = n; \</span>
<a name="l00391"></a>00391 <span class="preprocessor">                (l)-&gt;fav --; \</span>
<a name="l00392"></a>00392 <span class="preprocessor">                (l)-&gt;buf += n; \</span>
<a name="l00393"></a>00393 <span class="preprocessor">        } } while(0)</span>
<a name="l00394"></a>00394 <span class="preprocessor"></span>
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 <span class="comment">/* add field tag t with value v n bytes long */</span>
<a name="l00397"></a>00397 <span class="preprocessor">#define LADD( l, t, v, n ) do { \</span>
<a name="l00398"></a>00398 <span class="preprocessor">        if ( ((l)-&gt;fav &amp;&amp; LAVL(l) &gt;= n) || lExtend( l, n, 1 ) ) { \</span>
<a name="l00399"></a>00399 <span class="preprocessor">                LDEFNEWF( l, t ) \</span>
<a name="l00400"></a>00400 <span class="preprocessor">                memcpy( __f-&gt;val = (l)-&gt;buf, v, __f-&gt;len = n ); \</span>
<a name="l00401"></a>00401 <span class="preprocessor">                (l)-&gt;fav --; \</span>
<a name="l00402"></a>00402 <span class="preprocessor">                (l)-&gt;buf += n; \</span>
<a name="l00403"></a>00403 <span class="preprocessor">        } } while(0)</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span>
<a name="l00405"></a>00405 <span class="comment">/* append value v n bytes long */</span>
<a name="l00406"></a>00406 <span class="preprocessor">#define LAPP( l, v, n ) do { \</span>
<a name="l00407"></a>00407 <span class="preprocessor">        if ( LAVL(l) &gt;= n || lExtend( l, n, -1 ) ) { \</span>
<a name="l00408"></a>00408 <span class="preprocessor">                Fld *__f = LLAST(l); \</span>
<a name="l00409"></a>00409 <span class="preprocessor">                memcpy( (l)-&gt;buf, v, n ); \</span>
<a name="l00410"></a>00410 <span class="preprocessor">                __f-&gt;len += n; \</span>
<a name="l00411"></a>00411 <span class="preprocessor">                (l)-&gt;buf += n; \</span>
<a name="l00412"></a>00412 <span class="preprocessor">        } } while(0)</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span>
<a name="l00414"></a>00414 <span class="comment">/* add field tag t with int value i */</span>
<a name="l00415"></a>00415 <span class="preprocessor">#define LADDI( l, t, i ) do { \</span>
<a name="l00416"></a>00416 <span class="preprocessor">        if ( ((l)-&gt;fav &amp;&amp; LAVL(l) &gt;= 12) || lExtend( l, 12, 1 ) ) { \</span>
<a name="l00417"></a>00417 <span class="preprocessor">                LDEFNEWF( l, t ) \</span>
<a name="l00418"></a>00418 <span class="preprocessor">                (l)-&gt;buf += __f-&gt;len = i2a( __f-&gt;val = (l)-&gt;buf, i ); \</span>
<a name="l00419"></a>00419 <span class="preprocessor">                (l)-&gt;fav --; \</span>
<a name="l00420"></a>00420 <span class="preprocessor">        } } while(0)</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>
<a name="l00422"></a>00422 <span class="preprocessor">#define LADDS( l, t, s ) LADD( l, t, s, strlen(s) )</span>
<a name="l00423"></a>00423 <span class="preprocessor"></span><span class="preprocessor">#define LAPPS( l, s )    LAPP( l, s, strlen(s) )</span>
<a name="l00424"></a>00424 <span class="preprocessor"></span><span class="preprocessor">#define LADDF( l, f )    LADD( l, f-&gt;tag, f-&gt;val, f-&gt;len )</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span>
<a name="l00426"></a>00426 
<a name="l00436"></a>00436 <span class="comment">/*</span>
<a name="l00437"></a>00437 <span class="comment">        append canonical options fields.</span>
<a name="l00438"></a>00438 <span class="comment">        args starting with &apos;-&apos; are treated as options and appended as</span>
<a name="l00439"></a>00439 <span class="comment">        tab separated subfield w/o the &apos;-&apos;.</span>
<a name="l00440"></a>00440 <span class="comment">        If the first arg does not start with &apos;-&apos;, it is used as primary value.</span>
<a name="l00441"></a>00441 <span class="comment">        Other non-options are appended as subfields indicated by &apos;@&apos;.</span>
<a name="l00442"></a>00442 <span class="comment">        In order to skip the program&apos;s name, from main() use with argc-1,argv+1.</span>
<a name="l00443"></a>00443 <span class="comment">*/</span>
<a name="l00444"></a>00444 <span class="keyword">extern</span> <span class="keywordtype">int</span> lArgv ( <a class="code" href="structList.html">List</a> *l, <span class="keywordtype">int</span> tag, <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv );
<a name="l00445"></a>00445 <span class="comment">/*</span>
<a name="l00446"></a>00446 <span class="comment">        same using 0-terminated list.</span>
<a name="l00447"></a>00447 <span class="comment">extern int lArgs ( List *l, int tag, const char *arg, ... );</span>
<a name="l00448"></a>00448 <span class="comment">*/</span>
<a name="l00454"></a>00454 <span class="keyword">extern</span> <a class="code" href="structList.html">List</a> *lVar ( <a class="code" href="structList.html">List</a> *l, <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv );
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="comment">/* if siz is 0, rSiz() is used */</span>
<a name="l00457"></a>00457 <span class="keyword">extern</span> <span class="keywordtype">int</span> lCpy ( <a class="code" href="structList.html">List</a> *l, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *src, <span class="keywordtype">unsigned</span> siz );
<a name="l00458"></a>00458 <span class="preprocessor">#define LCPY( l, src ) lCpy( l, (src)-&gt;fld, LSIZ(src) )</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>
<a name="l00460"></a>00460 <span class="comment">/* create canned version of list as new record */</span>
<a name="l00461"></a>00461 <span class="preprocessor">#define LCAN( l ) rDup( (l)-&gt;fld, LSIZ(l) )</span>
<a name="l00462"></a>00462 <span class="preprocessor"></span>
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="comment">/*</span>
<a name="l00465"></a>00465 <span class="comment">        Print a field to list.</span>
<a name="l00466"></a>00466 <span class="comment">        a fmt of 0 indicates varargs.</span>
<a name="l00467"></a>00467 <span class="comment">*/</span>
<a name="l00468"></a>00468 <span class="keyword">extern</span> <span class="keywordtype">int</span> lOut ( <a class="code" href="structList.html">List</a> *to, <span class="keywordtype">int</span> tag, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ... );
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="comment">/*</span>
<a name="l00472"></a>00472 <span class="comment">        set the first field with tag to val (of len, -1 for strlen)</span>
<a name="l00473"></a>00473 <span class="comment">        kill additional fields with tag</span>
<a name="l00474"></a>00474 <span class="comment">        if no field found, add one at end</span>
<a name="l00475"></a>00475 <span class="comment">extern int lSet ( List *l, int tag, const char *val, unsigned len );</span>
<a name="l00476"></a>00476 <span class="comment">*/</span>
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keyword">enum</span> { <span class="comment">/* list parse state */</span>
<a name="l00480"></a>00480         LPS_SOR, <span class="comment">/* 0, at start of record */</span>
<a name="l00481"></a>00481         LPS_SOL = 0x1000000, <span class="comment">/* at start of line */</span>
<a name="l00482"></a>00482         LPS_TAG = 0x2000000, <span class="comment">/* in tag (only digits seen in line) */</span>
<a name="l00483"></a>00483         LPS_VAL = 0x3000000, <span class="comment">/* in val (some non-digit seen) */</span>
<a name="l00484"></a>00484         LPS_NEG = 0x4000000, <span class="comment">/* found &apos;-&apos; at start of line */</span>
<a name="l00485"></a>00485         LPS_CR  = 0x8000000, <span class="comment">/* kill carriage return character */</span>
<a name="l00486"></a>00486         LPS_LEN = 0x0ffffff
<a name="l00487"></a>00487 };
<a name="l00494"></a>00494 <span class="keyword">extern</span> <span class="keywordtype">int</span> lParse (<a class="code" href="structList.html">List</a> *l, <span class="keyword">const</span> <span class="keywordtype">char</span> *txt, <span class="keywordtype">int</span> lps);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 
<a name="l00507"></a>00507 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structSink.html">Sink</a> <a class="code" href="structSink.html">Sink</a>;
<a name="l00508"></a>00508 <span class="keyword">typedef</span> <span class="keywordtype">void</span> sink (<a class="code" href="structSink.html">Sink</a> *that, <span class="keywordtype">int</span> eor); <span class="comment">/* clean all or part of buffer(s) */</span>
<a name="l00509"></a>00509 
<a name="l00510"></a><a class="code" href="structSink.html">00510</a> <span class="keyword">struct </span><a class="code" href="structSink.html">Sink</a> {
<a name="l00511"></a>00511         <a class="code" href="structList.html">List</a>  lst;
<a name="l00512"></a>00512         sink *snk; <span class="comment">/* sinking function */</span>
<a name="l00513"></a>00513         <span class="keywordtype">void</span> *dst; <span class="comment">/* destination */</span>
<a name="l00514"></a>00514         <span class="keywordtype">int</span>   off; <span class="comment">/* start of current record in list, negative after partial flush */</span>
<a name="l00515"></a>00515 };
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="preprocessor">#define SINK(s) (s)-&gt;snk(s, 0)</span>
<a name="l00518"></a>00518 <span class="preprocessor"></span><span class="preprocessor">#define SEOR(s) (s)-&gt;snk(s, 1)</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span><span class="preprocessor">#define SCPY(s, l) do { LCPY(&amp;(s)-&gt;lst, l); SEOR(s); } while (0)</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span><span class="preprocessor">#define SCPYR(s, r) do { lCpy(&amp;(s)-&gt;lst, r, 0); SEOR(s); } while (0)</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span>
<a name="l00522"></a>00522 <span class="comment">/* ****************************************************************** */</span>
<a name="l00523"></a>00523 <span class="comment">/*                                                                    */</span>
<a name="l00524"></a>00524 <span class="comment">/* ENVIRONMENT AND SYSTEM                                             */</span>
<a name="l00525"></a>00525 <span class="comment">/*                                                                    */</span>
<a name="l00526"></a>00526 <span class="comment">/* ****************************************************************** */</span>
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">int</span> file;
<a name="l00530"></a>00530 <span class="preprocessor">#define FIL_NONE -1</span>
<a name="l00531"></a>00531 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">void</span> *file;
<a name="l00533"></a>00533 <span class="preprocessor">#define FIL_NONE 0</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span>
<a name="l00536"></a>00536 <span class="comment">/* environment.</span>
<a name="l00537"></a>00537 <span class="comment">*/</span>
<a name="l00538"></a><a class="code" href="structEnv.html">00538</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structEnv.html">Env</a> {
<a name="l00539"></a>00539         <a class="code" href="structList.html">List</a>     *opt; <span class="comment">/* options (header is packed command line) */</span>
<a name="l00540"></a>00540         file      in;
<a name="l00541"></a>00541         <a class="code" href="structSink.html">Sink</a>     *out; <span class="comment">/* a proper record sink expecting complete records */</span>
<a name="l00542"></a>00542         <a class="code" href="structSink.html">Sink</a>     *err; <span class="comment">/* a usually field buffered sink for eOut messages */</span>
<a name="l00543"></a>00543         <span class="keywordtype">int</span>       log; <span class="comment">/* level */</span>
<a name="l00544"></a>00544         <span class="keywordtype">int</span>       flg;
<a name="l00545"></a>00545         <span class="keywordtype">int</span>       wri; <span class="comment">/* write mode none/excl/shared */</span>
<a name="l00546"></a>00546         <span class="keywordtype">int</span>       sig; <span class="comment">/* interrupted by signal */</span>
<a name="l00547"></a>00547         <span class="keywordtype">unsigned</span>  psz; <span class="comment">/* system page size = 1&lt;&lt;psh enforced min 4K */</span>
<a name="l00548"></a>00548         <span class="keywordtype">int</span>       psh; <span class="comment">/* page shift (bits) 12..CPU_PAGE_SHIFT */</span>
<a name="l00549"></a>00549         <span class="keywordtype">unsigned</span>  rml; <span class="comment">/* r memory map limit (max pages per pointer map) */</span>
<a name="l00550"></a>00550         <span class="keywordtype">unsigned</span>  qml; <span class="comment">/* q memory map limit (max pages per tree map) */</span>
<a name="l00551"></a>00551         <span class="comment">/* LBlk     *blk[5]; for memory management */</span>
<a name="l00552"></a>00552 } <a class="code" href="structEnv.html">Env</a>;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="keyword">enum</span> { <span class="comment">/* env flags */</span>
<a name="l00555"></a>00555         ENV_BUFFER = 1, <span class="comment">/* env.err is buffered */</span>
<a name="l00556"></a>00556         ENV_MSYNC = 2 <span class="comment">/* use msync */</span>
<a name="l00557"></a>00557 };
<a name="l00558"></a>00558 <span class="keyword">enum</span> { <span class="comment">/* env writing mode */</span>
<a name="l00559"></a>00559         ENV_RO,    <span class="comment">/* readonly - not writing */</span>
<a name="l00560"></a>00560         ENV_EXCL  <span class="comment">/* exclusive access (the default) */</span>
<a name="l00561"></a>00561 <span class="preprocessor">#ifdef BUILD_SHMODE</span>
<a name="l00562"></a>00562 <span class="preprocessor"></span>        , ENV_SHARED <span class="comment">/* shared access */</span>
<a name="l00563"></a>00563 <span class="preprocessor">#endif</span>
<a name="l00564"></a>00564 <span class="preprocessor"></span>};
<a name="l00565"></a>00565 <span class="keyword">enum</span> { <span class="comment">/* signal code */</span>
<a name="l00566"></a>00566         ENV_CANCEL = 1, <span class="comment">/* abort current request */</span>
<a name="l00567"></a>00567         ENV_TERM <span class="comment">/* abort current request and exit */</span>
<a name="l00568"></a>00568 };
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="keyword">extern</span> <a class="code" href="structEnv.html">Env</a> env; <span class="comment">/* main environment */</span>
<a name="l00571"></a>00571 
<a name="l00575"></a>00575 <span class="keyword">enum</span> { <span class="comment">/* our very own errno */</span>
<a name="l00576"></a>00576         ERR_OK    = 0, <span class="comment">/* 0 is no error, also read(2)&apos;s EINTR, EAGAIN */</span>
<a name="l00577"></a>00577         ERR_NO    = -1, <span class="comment">/* get details from errno */</span>
<a name="l00578"></a>00578         <span class="comment">/* error level FATAL: we are wrong */</span>
<a name="l00579"></a>00579         ERR_IDIOT = -2, <span class="comment">/* caught programming error */</span>
<a name="l00580"></a>00580         ERR_TRASH = -3, <span class="comment">/* database internal consistency */</span>
<a name="l00581"></a>00581         LOG_FATAL   = ERR_TRASH, <span class="comment">/* fatal internal errors: we can&apos;t go on */</span>
<a name="l00582"></a>00582         <span class="comment">/* error levels SYERR,ERROR,IOERR: system or user was wrong */</span>
<a name="l00583"></a>00583         ERR_NOMEM = -4, <span class="comment">/* out of memory, also open(2)&apos;s EMFILE, ENFILE */</span>
<a name="l00584"></a>00584         ERR_IO    = -5, <span class="comment">/* real IO error, also write(2)&apos;s ENOSPC, EPIPE */</span>
<a name="l00585"></a>00585         ERR_BUSY  = -6, <span class="comment">/* object is busy */</span>
<a name="l00586"></a>00586         LOG_SYSERR  = ERR_BUSY, <span class="comment">/* problem with system ressources: bad file, no mem */</span>
<a name="l00587"></a>00587         ERR_BADF  = -7, <span class="comment">/* bad file, also read(2)&apos;s EINVAL, some of open(2) */</span>
<a name="l00588"></a>00588         ERR_FAULT = -8, <span class="comment">/* 0 pointer or bad sized buffer given */</span>
<a name="l00589"></a>00589         ERR_INVAL = -9, <span class="comment">/* general invalid parameters, any EINVAL errno */</span>
<a name="l00590"></a>00590         LOG_ERROR   = ERR_INVAL, <span class="comment">/* unusable input, database or query */</span>
<a name="l00591"></a>00591         ERR_AGAIN = -10, <span class="comment">/* no data at intr or nonblock */</span>
<a name="l00592"></a>00592         LOG_IOERR   = ERR_AGAIN, <span class="comment">/* problem on IO */</span>
<a name="l00593"></a>00593         LOG_WARN    = -11, <span class="comment">/* bad input */</span>
<a name="l00594"></a>00594         <span class="comment">/* logging levels: nothing was wrong */</span>
<a name="l00595"></a>00595         LOG_INFO    = -12, <span class="comment">/* some major event like opening a db */</span>
<a name="l00596"></a>00596         LOG_VERBOSE = -13, <span class="comment">/* any event like reading a record */</span>
<a name="l00597"></a>00597         LOG_DEBUG   = -14, <span class="comment">/* lots of processing details (debug built only) */</span>
<a name="l00598"></a>00598         LOG_TRACE   = -15, <span class="comment">/* database content (log_str) */</span>
<a name="l00599"></a>00599         LOG_ALL     = LOG_TRACE
<a name="l00600"></a>00600 };
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="preprocessor">#define EADD(t, v, n) LADD(&amp;env.out-&gt;lst, t, v, n)</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span><span class="preprocessor">#define EAPP(v, n)    LAPP(&amp;env.out-&gt;lst, v, n)</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span><span class="preprocessor">#define EADDS(t, s)   LADDS(&amp;env.out-&gt;lst, t, s)</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span><span class="preprocessor">#define EAPPS(s)      LAPPS(&amp;env.out-&gt;lst, s)</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span><span class="preprocessor">#define EADDI(t, i)   LADDI(&amp;env.out-&gt;lst, t, i)</span>
<a name="l00608"></a>00608 <span class="preprocessor"></span><span class="preprocessor">#define EADDF(f)      LADDF(&amp;env.out-&gt;lst, f)</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span>
<a name="l00610"></a>00610 <span class="comment">/*</span>
<a name="l00611"></a>00611 <span class="comment">        Append a field with abs(tag) to env.out for non-negative tags,</span>
<a name="l00612"></a>00612 <span class="comment">        else to env.err if tag &gt;= env&apos;s loglevel.</span>
<a name="l00613"></a>00613 <span class="comment">        For system errors, additional info is appended.</span>
<a name="l00614"></a>00614 <span class="comment">        env.err&apos;s eof is called, if any.</span>
<a name="l00615"></a>00615 <span class="comment">        returns tag</span>
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">        supports only a small subset of printf formats -- see the src</span>
<a name="l00618"></a>00618 <span class="comment">        has %b (bytes), which is like %.*s, but prints the string in hex</span>
<a name="l00619"></a>00619 <span class="comment">*/</span>
<a name="l00620"></a>00620 <span class="keyword">extern</span> <span class="keywordtype">int</span> eOut ( <span class="keywordtype">int</span> tag, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ... );
<a name="l00621"></a>00621 <span class="keyword">extern</span> <span class="keywordtype">int</span> eRr ( <span class="keywordtype">int</span> tag, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ... );
<a name="l00622"></a>00622 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span><span class="preprocessor"># define LOG_DBG eRr</span>
<a name="l00624"></a>00624 <span class="preprocessor"></span><span class="preprocessor">#elif defined( __GNUC__ )</span>
<a name="l00625"></a>00625 <span class="preprocessor"></span><span class="preprocessor"># define LOG_DBG( args... )</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00627"></a>00627 <span class="preprocessor"></span><span class="preprocessor"># define LOG_DBG (void) </span><span class="comment">/* compiler should dispose statement off */</span>
<a name="l00628"></a>00628 <span class="preprocessor">#endif</span>
<a name="l00629"></a>00629 <span class="preprocessor"></span>
<a name="l00636"></a>00636 <span class="keyword">extern</span> <span class="keywordtype">void</span> cInit ( <a class="code" href="structList.html">List</a> *args, <a class="code" href="structSink.html">Sink</a> *out, <a class="code" href="structSink.html">Sink</a> *err );
<a name="l00637"></a>00637 <span class="comment">/* typical usage from main() */</span>
<a name="l00638"></a>00638 <span class="preprocessor">#define CINIT(argl) cInit(lVar(lInit(argl,0), argc-1, argv+1), 0, 0)</span>
<a name="l00639"></a>00639 <span class="preprocessor"></span>
<a name="l00640"></a>00640 
<a name="l00647"></a>00647 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mAlloc ( <span class="keywordtype">int</span> size );
<a name="l00648"></a>00648 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mDup ( <span class="keyword">const</span> <span class="keywordtype">void</span> *str, <span class="keywordtype">int</span> size );
<a name="l00649"></a>00649 <span class="comment">/* cp siz bytes, append a 0 byte */</span>
<a name="l00650"></a>00650 <span class="keyword">extern</span> <span class="keywordtype">char</span> *mDupz ( <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> size );
<a name="l00651"></a>00651 <span class="keyword">extern</span> <span class="keywordtype">void</span> *mTryAlloc ( <span class="keywordtype">int</span> size );
<a name="l00652"></a>00652 <span class="keyword">extern</span> <span class="keywordtype">void</span>  mFree ( <span class="keywordtype">void</span> *mem );
<a name="l00653"></a>00653 <span class="keyword">extern</span> <a class="code" href="structFld.html">Fld</a>  *mFldAlloc ( <span class="keywordtype">int</span> nfields );
<a name="l00654"></a>00654 <span class="keyword">extern</span> <span class="keywordtype">void</span>  mFldFree ( <a class="code" href="structFld.html">Fld</a> *fld );
<a name="l00655"></a>00655 <span class="keyword">extern</span> <a class="code" href="structLBlk.html">LBlk</a> *mBlkAlloc ( <span class="keywordtype">int</span> size );
<a name="l00656"></a>00656 <span class="keyword">extern</span> <span class="keywordtype">void</span>  mBlkFree ( <a class="code" href="structLBlk.html">LBlk</a> *blk );
<a name="l00657"></a>00657 <span class="keyword">extern</span> <a class="code" href="structList.html">List</a> *mListAlloc ( <span class="keyword">const</span> <span class="keywordtype">char</span> *name ); <span class="comment">/* lInitialized with name */</span>
<a name="l00658"></a>00658 <span class="keyword">extern</span> <span class="keywordtype">void</span>  mListFree ( <a class="code" href="structList.html">List</a> *l );
<a name="l00659"></a>00659 <span class="preprocessor">#define mFldAlloc(n) ((Fld*)mAlloc((n)*sizeof(Fld)))</span>
<a name="l00660"></a>00660 <span class="preprocessor"></span><span class="preprocessor">#define mFldFree mFree</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span><span class="preprocessor">#define mBlkFree mFree</span>
<a name="l00662"></a>00662 <span class="preprocessor"></span><span class="preprocessor">#define MFREE(p) do { mFree(p); (p)=0; } while(0)</span>
<a name="l00663"></a>00663 <span class="preprocessor"></span>
<a name="l00664"></a>00664 
<a name="l00668"></a>00668 <span class="keyword">extern</span> <span class="keywordtype">int</span> tUpd ( lolo *tm );
<a name="l00676"></a>00676 <span class="keyword">extern</span> <span class="keywordtype">int</span> tGtf ( <span class="keywordtype">char</span> *buf, lolo *tm );
<a name="l00682"></a>00682 <span class="keyword">extern</span> <span class="keywordtype">char</span> *tGtfm ( <span class="keywordtype">char</span> *buf, lolo *tm );
<a name="l00686"></a>00686 <span class="keyword">extern</span> <span class="keywordtype">void</span> tSleep ( lolo tm );
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="comment">/* ************************************************************</span>
<a name="l00690"></a>00690 <span class="comment">        disk files (block devices)</span>
<a name="l00691"></a>00691 <span class="comment">*/</span>
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 <span class="keyword">enum</span> {
<a name="l00695"></a>00695         <span class="comment">/* basic open flags */</span>
<a name="l00696"></a>00696         FIL_RD    = 0x001, <span class="comment">/* shall be opened for input */</span>
<a name="l00697"></a>00697         FIL_WR    = 0x002, <span class="comment">/* shall be opened for output */</span>
<a name="l00698"></a>00698         FIL_RDWR  = 0x003, <span class="comment">/* shall be opened for both */</span>
<a name="l00699"></a>00699         FIL_TRY   = 0x004, <span class="comment">/* do not complain if open fails */</span>
<a name="l00700"></a>00700         <span class="comment">/* write flags */</span>
<a name="l00701"></a>00701         FIL_CREAT = 0x010, <span class="comment">/* shall be created */</span>
<a name="l00702"></a>00702         FIL_TRUNC = 0x020, <span class="comment">/* shall be truncated */</span>
<a name="l00703"></a>00703         FIL_SYNC  = 0x040, <span class="comment">/* syncing output */</span>
<a name="l00704"></a>00704         <span class="comment">/* lock flags */</span>
<a name="l00705"></a>00705         FIL_TLOCK = 0x100, <span class="comment">/* try locking (EX with WR) */</span>
<a name="l00706"></a>00706         FIL_BLOCK = 0x200, <span class="comment">/* blocking lock (EX with WR) */</span>
<a name="l00707"></a>00707         FIL_FLOCK = 0x300 <span class="comment">/* any locking is set */</span>
<a name="l00708"></a>00708 };
<a name="l00709"></a>00709 
<a name="l00715"></a>00715 <span class="keyword">extern</span> <span class="keywordtype">int</span> fOpen ( file *f, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> flags );
<a name="l00716"></a>00716 <span class="keyword">extern</span> <span class="keywordtype">int</span> fClose ( file *f );
<a name="l00717"></a>00717 <span class="keyword">extern</span> <span class="keywordtype">int</span> fSize ( file f );
<a name="l00718"></a>00718 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> fTime ( file f ); <span class="comment">/* mtime sec */</span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 <span class="comment">/*</span>
<a name="l00722"></a>00722 <span class="comment">        Like the syscalls, this returns the number of bytes on success, 0 on eof.</span>
<a name="l00723"></a>00723 <span class="comment">        fPwrite repeats and does not return an error when interrupted.</span>
<a name="l00724"></a>00724 <span class="comment">        On error, a negative value is returned.</span>
<a name="l00725"></a>00725 <span class="comment">*/</span>
<a name="l00726"></a>00726 <span class="keyword">extern</span> <span class="keywordtype">int</span> fRead ( file *f, <span class="keywordtype">void</span> *buf, <span class="keywordtype">unsigned</span> len );
<a name="l00727"></a>00727 <span class="keyword">extern</span> <span class="keywordtype">int</span> fWrite ( file *f, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">unsigned</span> len );
<a name="l00728"></a>00728 <span class="keyword">extern</span> <span class="keywordtype">int</span> fPread ( file *f, <span class="keywordtype">void</span> *buf, <span class="keywordtype">unsigned</span> len, <span class="keywordtype">unsigned</span> off );
<a name="l00729"></a>00729 <span class="keyword">extern</span> <span class="keywordtype">int</span> fPwrite ( file *f, <span class="keyword">const</span> <span class="keywordtype">void</span> *buf, <span class="keywordtype">unsigned</span> len, <span class="keywordtype">unsigned</span> off );
<a name="l00730"></a>00730 <span class="keyword">extern</span> <span class="keywordtype">int</span> fSeek ( file *f, <span class="keywordtype">unsigned</span> off );
<a name="l00731"></a>00731 <span class="keyword">extern</span> <span class="keywordtype">int</span> fTrunc ( file *f, <span class="keywordtype">unsigned</span> length );
<a name="l00732"></a>00732 <span class="preprocessor">#ifdef BUILD_SHMODE</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span><span class="comment">/* remove a full file lock as set by fOpen */</span>
<a name="l00734"></a>00734 <span class="keyword">extern</span> <span class="keywordtype">void</span> fUnlock ( file f );
<a name="l00735"></a>00735 <span class="comment">/*</span>
<a name="l00736"></a>00736 <span class="comment">        lock byte n</span>
<a name="l00737"></a>00737 <span class="comment">        use TLOCK or BLOCK, possibly with WR, to lock, 0 to unlock.</span>
<a name="l00738"></a>00738 <span class="comment">*/</span>
<a name="l00739"></a>00739 <span class="keyword">extern</span> <span class="keywordtype">int</span> fLock ( file f, <span class="keywordtype">unsigned</span> n, <span class="keywordtype">int</span> flg );
<a name="l00740"></a>00740 <span class="preprocessor">#define FLOCK(f,n,flg) (ENV_SHARED==env.wri &amp;&amp; fLock(f,n,flg))</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00742"></a>00742 <span class="preprocessor"></span><span class="preprocessor">#define FLOCK(f,n,flg) 0</span>
<a name="l00743"></a>00743 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00744"></a>00744 <span class="preprocessor"></span><span class="preprocessor">#define FLOCKSH(f,n) FLOCK(f,n,FIL_BLOCK)</span>
<a name="l00745"></a>00745 <span class="preprocessor"></span><span class="preprocessor">#define FLOCKEX(f,n) FLOCK(f,n,FIL_BLOCK|FIL_WR)</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span><span class="preprocessor">#define FLOCKUN(f,n) FLOCK(f,n,0)</span>
<a name="l00747"></a>00747 <span class="preprocessor"></span>
<a name="l00756"></a>00756 <span class="keyword">extern</span> <span class="keywordtype">int</span> fSlurp ( <span class="keywordtype">char</span> **buf, <span class="keywordtype">int</span> sz, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> opt );
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="comment">/* record-oriented sink to (file)dst.</span>
<a name="l00759"></a>00759 <span class="comment">        Expects the list to contain a proper record.</span>
<a name="l00760"></a>00760 <span class="comment">        If the header starts with a digit, a W&lt;TAB&gt; is prepended.</span>
<a name="l00761"></a>00761 <span class="comment">        An empty header is ommited.</span>
<a name="l00762"></a>00762 <span class="comment">*/</span>
<a name="l00763"></a>00763 <span class="keyword">extern</span> <span class="keywordtype">void</span> fSinkr (<a class="code" href="structSink.html">Sink</a> *that, <span class="keywordtype">int</span> eor);
<a name="l00764"></a>00764 <span class="comment">/* line-oriented sink (field values only) to (file)dst.</span>
<a name="l00765"></a>00765 <span class="comment">        leaves the header alone, ignores tags and blank values.</span>
<a name="l00766"></a>00766 <span class="comment">        yet prints a blank line on eor.</span>
<a name="l00767"></a>00767 <span class="comment">*/</span>
<a name="l00768"></a>00768 <span class="keyword">extern</span> <span class="keywordtype">void</span> fSinkl (<a class="code" href="structSink.html">Sink</a> *that, <span class="keywordtype">int</span> eor);
<a name="l00769"></a>00769 
<a name="l00771"></a><a class="code" href="structFMap.html">00771</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00772"></a>00772         file     fil;
<a name="l00773"></a>00773         <span class="keywordtype">int</span>      flg;
<a name="l00774"></a>00774         <span class="keywordtype">char</span>    *map;
<a name="l00775"></a>00775         <span class="keywordtype">unsigned</span> npg; <span class="comment">/* in pages of env.psz */</span>
<a name="l00776"></a>00776         <span class="keywordtype">unsigned</span> lim; <span class="comment">/* max pages to map */</span>
<a name="l00777"></a>00777 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00778"></a>00778 <span class="preprocessor"></span>        <span class="keywordtype">char</span>    *nam; <span class="comment">/* for shared mapping */</span>
<a name="l00779"></a>00779         <span class="keywordtype">void</span>    *hdl; <span class="comment">/* &quot;mapping object&quot; */</span>
<a name="l00780"></a>00780 <span class="preprocessor">#endif</span>
<a name="l00781"></a>00781 <span class="preprocessor"></span>} <a class="code" href="structFMap.html">FMap</a>;
<a name="l00782"></a>00782 
<a name="l00787"></a>00787 <span class="keyword">extern</span> <span class="keywordtype">int</span> fMOpen ( <a class="code" href="structFMap.html">FMap</a> *fm, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> flags );
<a name="l00788"></a>00788 <span class="keyword">extern</span> <span class="keywordtype">int</span> fMClose ( <a class="code" href="structFMap.html">FMap</a> *fm );
<a name="l00798"></a>00798 <span class="keyword">extern</span> <span class="keywordtype">int</span> fMap ( <a class="code" href="structFMap.html">FMap</a> *fm, <span class="keywordtype">unsigned</span> npg );
<a name="l00800"></a>00800 <span class="keyword">extern</span> <span class="keywordtype">int</span> fMSync ( <a class="code" href="structFMap.html">FMap</a> *fm, <span class="keywordtype">unsigned</span> page );
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 <span class="comment">/*</span>
<a name="l00804"></a>00804 <span class="comment">        file input buffer structure for fGets.</span>
<a name="l00805"></a>00805 <span class="comment">        suitable for both temp fix buffers and, with some care, for List buffers.</span>
<a name="l00806"></a>00806 <span class="comment">*/</span>
<a name="l00807"></a><a class="code" href="structFBuf.html">00807</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00808"></a>00808         file      f; <span class="comment">/* file to read from */</span>
<a name="l00809"></a>00809         <span class="keywordtype">unsigned</span>  n; <span class="comment">/* current line number (1 based) */</span>
<a name="l00810"></a>00810         <span class="keywordtype">unsigned</span>  o; <span class="comment">/* offset of p from file start */</span>
<a name="l00811"></a>00811         <span class="keywordtype">char</span>     *b; <span class="comment">/* buffer base (const) */</span>
<a name="l00812"></a>00812         <span class="keywordtype">unsigned</span>  s; <span class="comment">/* buffer size (const) */</span>
<a name="l00813"></a>00813         <span class="keywordtype">char</span>     *p; <span class="comment">/* start of current line */</span>
<a name="l00814"></a>00814         <span class="keywordtype">unsigned</span>  l; <span class="comment">/* line len */</span>
<a name="l00815"></a>00815         <span class="keywordtype">unsigned</span>  m; <span class="comment">/* more bytes after p+l (including the LF) */</span>
<a name="l00816"></a>00816 } <a class="code" href="structFBuf.html">FBuf</a>;
<a name="l00817"></a>00817 <span class="comment">/* sloppy but convenient initializer macro */</span>
<a name="l00818"></a>00818 <span class="preprocessor">#define FIL_BUF( fb, fil, buf )  do { \</span>
<a name="l00819"></a>00819 <span class="preprocessor">        fb.f = fil; fb.b = fb.p = buf; fb.s = sizeof(buf); \</span>
<a name="l00820"></a>00820 <span class="preprocessor">        fb.n = 1; fb.o = fb.l = fb.m = 0; \</span>
<a name="l00821"></a>00821 <span class="preprocessor">        } while (0)</span>
<a name="l00822"></a>00822 <span class="preprocessor"></span><span class="comment">/* even more convenient macro, must be end of data def */</span>
<a name="l00823"></a>00823 <span class="preprocessor">#define FIL_DEFBUF( f ) \</span>
<a name="l00824"></a>00824 <span class="preprocessor">        char buf[0x2000]; \</span>
<a name="l00825"></a>00825 <span class="preprocessor">        FBuf fb; \</span>
<a name="l00826"></a>00826 <span class="preprocessor">        FIL_BUF(fb, f, buf);</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00828"></a>00828 <span class="comment">        set p and l to next line, lines are terminated by LF.</span>
<a name="l00829"></a>00829 <span class="comment">        if l, advance p after current line.</span>
<a name="l00830"></a>00830 <span class="comment">        if m, skip next byte.</span>
<a name="l00831"></a>00831 <span class="comment">        if m, search for newline.</span>
<a name="l00832"></a>00832 <span class="comment">        if no newline found, mv p downto b and read more chars upto s.</span>
<a name="l00833"></a>00833 <span class="comment">        if l==s, buffer is exhausted (and m is 0).</span>
<a name="l00834"></a>00834 <span class="comment">        else if m, p[l] is a newline.</span>
<a name="l00835"></a>00835 <span class="comment">        else if FIL_NONE == f,</span>
<a name="l00836"></a>00836 <span class="comment">        no bytes could be read (an eof was seen or somebody set NBLOCK).</span>
<a name="l00837"></a>00837 <span class="comment">        return whether we got a line</span>
<a name="l00838"></a>00838 <span class="comment">*/</span>
<a name="l00839"></a>00839 <span class="keyword">extern</span> <span class="keywordtype">int</span> fGets ( <a class="code" href="structFBuf.html">FBuf</a> *fb );
<a name="l00840"></a>00840 <span class="keyword">extern</span> <span class="keywordtype">int</span> fGetr ( <a class="code" href="structList.html">List</a> *l, <a class="code" href="structFBuf.html">FBuf</a> *fb );
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 <span class="comment">/* ****************************************************************** */</span>
<a name="l00845"></a>00845 <span class="comment">/*                                                                    */</span>
<a name="l00846"></a>00846 <span class="comment">/* DATABASE                                                           */</span>
<a name="l00847"></a>00847 <span class="comment">/*                                                                    */</span>
<a name="l00848"></a>00848 <span class="comment">/* ****************************************************************** */</span>
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 <span class="keyword">enum</span> { <span class="comment">/* flags for record and query data/index file pairs */</span>
<a name="l00851"></a>00851         DX_OPEN  = 0x1, <span class="comment">/* open */</span>
<a name="l00852"></a>00852         DX_WRITE = 0x2, <span class="comment">/* open for writing */</span>
<a name="l00853"></a>00853         DX_ASYNC = 0x4, <span class="comment">/* no synced write */</span>
<a name="l00854"></a>00854         DX_MODIF = 0x8  <span class="comment">/* modified */</span>
<a name="l00855"></a>00855 };
<a name="l00861"></a><a class="code" href="structRdx.html">00861</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structRdx.html">Rdx</a> {
<a name="l00862"></a>00862         file        mrd;
<a name="l00863"></a>00863         <a class="code" href="structFMap.html">FMap</a>        mrx;
<a name="l00864"></a>00864         <span class="keywordtype">int</span>         flg;
<a name="l00865"></a>00865         <span class="keywordtype">int</span>         mid; <span class="comment">/* in records == maxid */</span>
<a name="l00866"></a>00866         <span class="keywordtype">int</span>         rdl; <span class="comment">/* length of data file in bytes */</span>
<a name="l00867"></a>00867         <span class="keywordtype">int</span>         ptl; <span class="comment">/* pointer bytes, by now always 8 */</span>
<a name="l00868"></a>00868         <span class="keywordtype">int</span>         typ; <span class="comment">/* type of pointer file */</span>
<a name="l00869"></a>00869 } <a class="code" href="structRdx.html">Rdx</a>;
<a name="l00870"></a>00870 
<a name="l00872"></a>00872 <span class="keyword">extern</span> <span class="keywordtype">int</span> rInit ( <a class="code" href="structRdx.html">Rdx</a> *rdx );
<a name="l00874"></a>00874 <span class="keyword">extern</span> <span class="keywordtype">void</span> rFini ( <a class="code" href="structRdx.html">Rdx</a> *rdx );
<a name="l00875"></a>00875 
<a name="l00876"></a>00876 <span class="comment">/*</span>
<a name="l00877"></a>00877 <span class="comment">        read record rid.</span>
<a name="l00878"></a>00878 <span class="comment">        if mpos and the rec is found at mpos or higher,</span>
<a name="l00879"></a>00879 <span class="comment">        rRead will backtrack to earlier versions.</span>
<a name="l00880"></a>00880 <span class="comment">*/</span>
<a name="l00881"></a>00881 <span class="keyword">extern</span> <span class="keywordtype">int</span> rRead ( <a class="code" href="structList.html">List</a> *l, <a class="code" href="structRdx.html">Rdx</a> *rdx, <span class="keywordtype">int</span> rid, <span class="keywordtype">unsigned</span> mpos );
<a name="l00882"></a>00882 <span class="comment">/*</span>
<a name="l00883"></a>00883 <span class="comment">        write a record</span>
<a name="l00884"></a>00884 <span class="comment">        use rid 0 to get new rid</span>
<a name="l00885"></a>00885 <span class="comment">        use opos -1 if you don&apos;t care about old pos</span>
<a name="l00886"></a>00886 <span class="comment">        to be transparent here, the rid@pos as found in standard recs</span>
<a name="l00887"></a>00887 <span class="comment">        is ignored and should be pre-skipped up to the leader.</span>
<a name="l00888"></a>00888 <span class="comment">        specify the record size if known, with 0, rSiz will be used</span>
<a name="l00889"></a>00889 <span class="comment">        @return the record id written (&gt; 0) on success, &lt;= 0 on error</span>
<a name="l00890"></a>00890 <span class="comment">*/</span>
<a name="l00891"></a>00891 <span class="keyword">extern</span> <span class="keywordtype">int</span> rWrite ( <a class="code" href="structRdx.html">Rdx</a> *rdx, <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *r, <span class="keywordtype">int</span> rid, <span class="keywordtype">int</span> opos, <span class="keywordtype">unsigned</span> siz );
<a name="l00892"></a>00892 
<a name="l00893"></a>00893 
<a name="l00902"></a>00902 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structCdx.html">Cdx</a> <a class="code" href="structCdx.html">Cdx</a>;
<a name="l00903"></a>00903 
<a name="l00904"></a><a class="code" href="structQdx.html">00904</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structQdx.html">Qdx</a> { <span class="comment">/* actually it&apos;s a B-Link-Tree */</span>
<a name="l00905"></a>00905         file           mqd; <span class="comment">/* the leaves file */</span>
<a name="l00906"></a>00906         <a class="code" href="structFMap.html">FMap</a>           mqx; <span class="comment">/* the tree file */</span>
<a name="l00907"></a>00907         <span class="keyword">const</span> <a class="code" href="structCdx.html">Cdx</a>     *cdx; <span class="comment">/* the collation */</span>
<a name="l00908"></a>00908         <span class="keywordtype">int</span>            flg; <span class="comment">/* flags: writeable */</span>
<a name="l00909"></a>00909         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  typ; <span class="comment">/* cfg: leaf block type */</span>
<a name="l00910"></a>00910         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  ksz; <span class="comment">/* cfg: max key length, default 255 */</span>
<a name="l00911"></a>00911         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  ptr; <span class="comment">/* cfg: inverted file pointer type or plain value size */</span>
<a name="l00912"></a>00912         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  let; <span class="comment">/* cfg: pct free on load */</span>
<a name="l00913"></a>00913         <span class="comment">/* members set automatically:  */</span>
<a name="l00914"></a>00914         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  vsz; <span class="comment">/* value size, min 4, default 8 */</span>
<a name="l00915"></a>00915         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  uni; <span class="comment">/* value unique length (see qSet) */</span>
<a name="l00916"></a>00916         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  ftp; <span class="comment">/* fork block type */</span>
<a name="l00917"></a>00917         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  dpt; <span class="comment">/* depth (level of root over bottom &gt; 0) */</span>
<a name="l00918"></a>00918         <span class="keywordtype">unsigned</span>       lsz; <span class="comment">/* leaf block size computed from type */</span>
<a name="l00919"></a>00919         <span class="keywordtype">unsigned</span>       lln; <span class="comment">/* # leaf blocks in index */</span>
<a name="l00920"></a>00920         <span class="keywordtype">unsigned</span>       fln; <span class="comment">/* # fork blocks in index */</span>
<a name="l00921"></a>00921         <span class="comment">/* members considered internal:  */</span>
<a name="l00922"></a>00922         <span class="keyword">struct </span><a class="code" href="structQLoad.html">QLoad</a>  *qld;
<a name="l00923"></a>00923 } <a class="code" href="structQdx.html">Qdx</a>;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="keyword">enum</span> { <span class="comment">/* btree block type, size, flg */</span>
<a name="l00926"></a>00926         QDX_TYPMSK = 0xC0, <span class="comment">/* highest 2 bits: basic type */</span>
<a name="l00927"></a>00927         QDX_LEAF   = 0x00, <span class="comment">/* leaf block, portable */</span>
<a name="l00928"></a>00928         QDX_FORKLE = 0x40, <span class="comment">/* fork block little endian */</span>
<a name="l00929"></a>00929         QDX_FORKBE = 0x80, <span class="comment">/* fork block big endian */</span>
<a name="l00930"></a>00930         QDX_LEAFPV = 0xC0, <span class="comment">/* leaf plain values (forks don&apos;t care) */</span>
<a name="l00931"></a>00931         <span class="comment">/* next 2 bits 0x30 for future extensions */</span>
<a name="l00932"></a>00932         QDX_COMPRS = 0x08, <span class="comment">/* flag compressed keys (not yet supported) */</span>
<a name="l00933"></a>00933         QDX_SIZMSK = 0x07, <span class="comment">/* lowest 3 bits: blocksize */</span>
<a name="l00934"></a>00934         QDX_LEAF0K = 0x00, <span class="comment">/* 1/2K blocks 0x0200 9+0 bits */</span>
<a name="l00935"></a>00935         QDX_LEAF1K = 0x01, <span class="comment">/* 1K blocks 0x0400 */</span>
<a name="l00936"></a>00936         QDX_LEAF2K = 0x02, <span class="comment">/* 2K blocks 0x0800 */</span>
<a name="l00937"></a>00937         QDX_LEAF4K = 0x03, <span class="comment">/* 4K blocks 0x1000 */</span>
<a name="l00938"></a>00938         QDX_LEAF8K = 0x04  <span class="comment">/* 8K blocks 0x2000, max for leaves */</span>
<a name="l00939"></a>00939 };
<a name="l00940"></a>00940 <span class="keyword">enum</span> {
<a name="l00941"></a>00941         QDX_MAXVALPERLEAF = 0x800, <span class="comment">/* max 8K / min 4 bytes vsz */</span>
<a name="l00942"></a>00942         QDX_LEAFSH =   9, <span class="comment">/* leaf size shift+(0..4) ~ 512 bytes - 8K */</span>
<a name="l00943"></a>00943         QDX_FORKSH =  12  <span class="comment">/* fork size shift+(0..4) ~ 4K - 64K */</span>
<a name="l00944"></a>00944 };
<a name="l00945"></a>00945 
<a name="l00946"></a><a class="code" href="structVal.html">00946</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00947"></a>00947         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> len;
<a name="l00948"></a>00948         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byt[255];
<a name="l00949"></a>00949 }       <a class="code" href="structVal.html">Val</a>;
<a name="l00950"></a>00950 
<a name="l00951"></a><a class="code" href="structKey.html">00951</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00952"></a>00952         <a class="code" href="structVal.html">Val</a>           val;
<a name="l00953"></a>00953         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> len;
<a name="l00954"></a>00954         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byt[255];
<a name="l00955"></a>00955 }       <a class="code" href="structKey.html">Key</a>;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structQLoop.html">QLoop</a> <a class="code" href="structQLoop.html">QLoop</a>;
<a name="l00965"></a>00965 <span class="keyword">typedef</span> <span class="keywordtype">int</span> QCb ( <a class="code" href="structQLoop.html">QLoop</a> *<span class="keyword">self</span> );
<a name="l00966"></a>00966 
<a name="l00967"></a><a class="code" href="structQLoop.html">00967</a> <span class="keyword">struct </span><a class="code" href="structQLoop.html">QLoop</a> {
<a name="l00968"></a>00968         QCb   *qcb;
<a name="l00969"></a>00969         <a class="code" href="structQdx.html">Qdx</a>   *qdx;
<a name="l00970"></a>00970         <span class="keywordtype">int</span>    flg;
<a name="l00971"></a>00971         <a class="code" href="structKey.html">Key</a>    key;
<a name="l00972"></a>00972         <a class="code" href="structKey.html">Key</a>    to;
<a name="l00973"></a>00973         <span class="comment">/* set on callback: */</span>
<a name="l00974"></a>00974         <a class="code" href="structKey.html">Key</a>    cur;
<a name="l00975"></a>00975         <span class="keywordtype">unsigned</span>            nvals;
<a name="l00976"></a>00976         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *vals;
<a name="l00977"></a>00977 };
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="keyword">enum</span> { <span class="comment">/* flags */</span>
<a name="l00980"></a>00980         QLOOP = 0, <span class="comment">/* loop endless */</span>
<a name="l00981"></a>00981         <span class="comment">/* stop based on QLoop.key */</span>
<a name="l00982"></a>00982         QEQ   = 1, <span class="comment">/* loop while == key */</span>
<a name="l00983"></a>00983         QPF   = 2, <span class="comment">/* loop on prefix key */</span>
<a name="l00984"></a>00984         <span class="comment">/* stop based on QLoop.to */</span>
<a name="l00985"></a>00985         QUPTO = 4, <span class="comment">/* loop while &lt; to */</span>
<a name="l00986"></a>00986         QINCL = 5, <span class="comment">/* loop while &lt;= to */</span>
<a name="l00987"></a>00987         QSTOP = 7, <span class="comment">/* mask for stop mode */</span>
<a name="l00988"></a>00988         QSKIP = 8, <span class="comment">/* skip the from key */</span>
<a name="l00989"></a>00989         QSAME = 0x10 <span class="comment">/* callback on same key */</span>
<a name="l00990"></a>00990 };
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 
<a name="l00994"></a>00994 <span class="keyword">extern</span> <span class="keywordtype">int</span> qInit ( <a class="code" href="structQdx.html">Qdx</a> *bt );
<a name="l00996"></a>00996 <span class="keyword">extern</span> <span class="keywordtype">void</span> qFini ( <a class="code" href="structQdx.html">Qdx</a> *bt );
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 <span class="comment">/*</span>
<a name="l00999"></a>00999 <span class="comment">        load a sorted series of keys and hits into index.</span>
<a name="l01000"></a>01000 <span class="comment">        call repeatedly, using a key with val.len 0 in last call</span>
<a name="l01001"></a>01001 <span class="comment">*/</span>
<a name="l01002"></a>01002 <span class="keyword">extern</span> <span class="keywordtype">int</span> qLoad ( <a class="code" href="structQdx.html">Qdx</a> *bt, <a class="code" href="structKey.html">Key</a> *key );
<a name="l01003"></a>01003 <span class="keyword">extern</span> <span class="keywordtype">int</span> qLoadf ( <a class="code" href="structQdx.html">Qdx</a> *bt, file *f );
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 <span class="comment">/*</span>
<a name="l01006"></a>01006 <span class="comment">        write the key-value pair to the index and return 0, unless:</span>
<a name="l01007"></a>01007 <span class="comment">        - the value is zero on the 1st uni bytes</span>
<a name="l01008"></a>01008 <span class="comment">          and there is already such a value (unique key, return 3)</span>
<a name="l01009"></a>01009 <span class="comment">        - there is an all-zero value for the key (stopword, return 2)</span>
<a name="l01010"></a>01010 <span class="comment">        - it is already there (full duplicate found, return 1)</span>
<a name="l01011"></a>01011 <span class="comment">        With plain values, only full duplicates are checked.</span>
<a name="l01012"></a>01012 <span class="comment">        Uni is usually the length of the initial segment of value,</span>
<a name="l01013"></a>01013 <span class="comment">        which is the rid in fulltext mode, else the tag.</span>
<a name="l01014"></a>01014 <span class="comment">        Where a unique key is found, the value is copied to key.</span>
<a name="l01015"></a>01015 <span class="comment">*/</span>
<a name="l01016"></a>01016 <span class="keyword">extern</span> <span class="keywordtype">int</span> qSet ( <a class="code" href="structQdx.html">Qdx</a> *bt, <a class="code" href="structKey.html">Key</a> *key );
<a name="l01017"></a>01017 <span class="keyword">enum</span> {
<a name="l01018"></a>01018         QST_OK,
<a name="l01019"></a>01019         QST_FOUND,
<a name="l01020"></a>01020         QST_STPWRD,
<a name="l01021"></a>01021         QST_UNIKEY
<a name="l01022"></a>01022 };
<a name="l01023"></a>01023 <span class="comment">/*</span>
<a name="l01024"></a>01024 <span class="comment">        delete a key-value pair. return 1 if found, else 0</span>
<a name="l01025"></a>01025 <span class="comment">*/</span>
<a name="l01026"></a>01026 <span class="keyword">extern</span> <span class="keywordtype">int</span> qDel ( <a class="code" href="structQdx.html">Qdx</a> *bt, <a class="code" href="structKey.html">Key</a> *key );
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="keyword">extern</span> <span class="keywordtype">int</span> qLoop ( <a class="code" href="structQLoop.html">QLoop</a> *<span class="keyword">self</span> );
<a name="l01029"></a>01029 
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="comment">/*</span>
<a name="l01032"></a>01032 <span class="comment">        standard values structured as pointers</span>
<a name="l01033"></a>01033 <span class="comment">        denoting a record and position where key occurred.</span>
<a name="l01034"></a>01034 <span class="comment">        The value structure is up to 3 big endian unsigned numbers:</span>
<a name="l01035"></a>01035 <span class="comment">        0..2 bytes for tag,</span>
<a name="l01036"></a>01036 <span class="comment">        3+(0..3) bytes for rid (in fulltext mode: before the tag) and</span>
<a name="l01037"></a>01037 <span class="comment">        0..4 bytes for pos,</span>
<a name="l01038"></a>01038 <span class="comment">        totalling from 4 (vsz min.) to 12 bytes.</span>
<a name="l01039"></a>01039 <span class="comment">*/</span>
<a name="l01040"></a><a class="code" href="structPtr.html">01040</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="comment">/* where a key has a hit */</span>
<a name="l01041"></a>01041         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> tag; <span class="comment">/* while neg. tags are allowed, sorting is unsigned */</span>
<a name="l01042"></a>01042         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> ext; <span class="comment">/* extend row id to six bytes (used as db number) */</span>
<a name="l01043"></a>01043         <span class="keywordtype">unsigned</span>       rid; <span class="comment">/* row id */</span>
<a name="l01044"></a>01044         <span class="keywordtype">unsigned</span>       pos; <span class="comment">/* word pos, usually with field occ&lt;&lt;16 */</span>
<a name="l01045"></a>01045 }       <a class="code" href="structPtr.html">Ptr</a>;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 <span class="keyword">enum</span> {
<a name="l01048"></a>01048         QDX_TAGMSK = 0xC0, <span class="comment">/* mask length of tag 0..2 */</span>
<a name="l01049"></a>01049         QDX_TAG1   = 0x40,
<a name="l01050"></a>01050         QDX_TAG2   = 0x80,
<a name="l01051"></a>01051         QDX_TAGSH  =    6, <span class="comment">/* ... shifted by 6 */</span>
<a name="l01052"></a>01052         QDX_RIDMSK = 0x30, <span class="comment">/* mask length of rid 0..3 */</span>
<a name="l01053"></a>01053         QDX_RIDMIN =    3, <span class="comment">/* based on 3 */</span>
<a name="l01054"></a>01054         QDX_RIDSH  =    4, <span class="comment">/* ... shifted by 4 */</span>
<a name="l01055"></a>01055         QDX_RID3   = 0x00,
<a name="l01056"></a>01056         QDX_RID4   = 0x10,
<a name="l01057"></a>01057         QDX_RID5   = 0x20,
<a name="l01058"></a>01058         QDX_RID6   = 0x30,
<a name="l01059"></a>01059         QDX_FULTXT = 0x08, <span class="comment">/* traditional fulltext ordering */</span>
<a name="l01060"></a>01060         QDX_POSMSK = 0x07, <span class="comment">/* mask length pos info 0..4 */</span>
<a name="l01061"></a>01061         <span class="comment">/* default settings based on 3 byte rid */</span>
<a name="l01062"></a>01062         QDX_ISIS   = QDX_RID3|QDX_TAG2|QDX_FULTXT|3,
<a name="l01063"></a>01063         <span class="comment">/* 0x8B, 8 byte fulltext 3+2+3 IFP format */</span>
<a name="l01064"></a>01064         QDX_STDDB  = QDX_TAG1|QDX_RID3
<a name="l01065"></a>01065         <span class="comment">/* 0x40, 4 byte 3 rid + 1 for 256 field tags */</span>
<a name="l01066"></a>01066 };
<a name="l01067"></a>01067 
<a name="l01068"></a>01068 <span class="comment">/* decode a value to a pointer */</span>
<a name="l01069"></a>01069 <span class="keyword">extern</span> <span class="keywordtype">void</span> qRdVal ( <a class="code" href="structPtr.html">Ptr</a> *ptr, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *val, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> typ );
<a name="l01070"></a>01070 <span class="comment">/* create a value from hit. */</span>
<a name="l01071"></a>01071 <span class="keyword">extern</span> <span class="keywordtype">void</span> qMkVal ( <a class="code" href="structVal.html">Val</a> *val, <a class="code" href="structPtr.html">Ptr</a> *ptr, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> typ );
<a name="l01072"></a>01072 <span class="comment">/* decode a key to plaintext */</span>
<a name="l01073"></a>01073 <span class="keyword">extern</span> <span class="keywordtype">int</span> qRdKey ( <a class="code" href="structQdx.html">Qdx</a> *qdx, <span class="keywordtype">char</span> *plain, <span class="keywordtype">int</span> l, <a class="code" href="structKey.html">Key</a> *key );
<a name="l01074"></a>01074 <span class="comment">/* create a key from plaintext, truncating to ksz. */</span>
<a name="l01075"></a>01075 <span class="keyword">extern</span> <span class="keywordtype">void</span> qMkKey ( <a class="code" href="structQdx.html">Qdx</a> *qdx, <a class="code" href="structKey.html">Key</a> *key, <span class="keywordtype">char</span> *b, <span class="keywordtype">int</span> l );
<a name="l01076"></a>01076 <span class="comment">/* create a key and value from line. */</span>
<a name="l01077"></a>01077 <span class="keyword">extern</span> <span class="keywordtype">int</span> qMkKeyVal ( <a class="code" href="structQdx.html">Qdx</a> *qdx, <a class="code" href="structKey.html">Key</a> *key, <span class="keywordtype">char</span> *b, <span class="keywordtype">int</span> l );
<a name="l01078"></a>01078 
<a name="l01079"></a>01079 
<a name="l01080"></a><a class="code" href="structQSet.html">01080</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01081"></a>01081         <a class="code" href="structQdx.html">Qdx</a> *qdx;
<a name="l01082"></a>01082         <span class="keywordtype">int</span>  del;
<a name="l01083"></a>01083         <a class="code" href="structKey.html">Key</a>  pfx;
<a name="l01084"></a>01084         <a class="code" href="structPtr.html">Ptr</a>  ptr;
<a name="l01085"></a>01085 } <a class="code" href="structQSet.html">QSet</a>;
<a name="l01086"></a>01086 <span class="comment">/*</span>
<a name="l01087"></a>01087 <span class="comment">        set or del one keys</span>
<a name="l01088"></a>01088 <span class="comment">        basically this behaves like qMkKey, qMkVal, qSet</span>
<a name="l01089"></a>01089 <span class="comment">        ptr.pos is incremented</span>
<a name="l01090"></a>01090 <span class="comment">        with pfx, pfx is prepended to the key (before qMkKey)</span>
<a name="l01091"></a>01091 <span class="comment">*/</span>
<a name="l01092"></a>01092 <span class="keyword">extern</span> <span class="keywordtype">int</span> qSetKeyVal (<a class="code" href="structQSet.html">QSet</a> *qst, <span class="keywordtype">char</span> *val, <span class="keywordtype">int</span> len);
<a name="l01093"></a>01093 <span class="comment">/*</span>
<a name="l01094"></a>01094 <span class="comment">        split the value into words and qSetKeyVal each</span>
<a name="l01095"></a>01095 <span class="comment">        return the number of entries made</span>
<a name="l01096"></a>01096 <span class="comment">*/</span>
<a name="l01097"></a>01097 <span class="keyword">extern</span> <span class="keywordtype">int</span> qSetKeyVals (<a class="code" href="structQSet.html">QSet</a> *qst, <span class="keywordtype">char</span> *val, <span class="keywordtype">int</span> len);
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 
<a name="l01103"></a>01103 <span class="preprocessor">#define CDX_MAXSEQ 15   </span><span class="comment">/* max byte sequence length */</span>
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="keyword">extern</span> <span class="keyword">const</span> <a class="code" href="structCdx.html">Cdx</a> *cOpen ( <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a> *src );
<a name="l01107"></a>01107 <span class="keyword">extern</span> <span class="keywordtype">int</span> cEnc ( <span class="keyword">const</span> <a class="code" href="structCdx.html">Cdx</a> *cdx, <a class="code" href="structKey.html">Key</a> *key, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *b, <span class="keywordtype">int</span> l, <span class="keywordtype">int</span> w );
<a name="l01108"></a>01108 <span class="keyword">extern</span> <span class="keywordtype">int</span> cDec ( <span class="keyword">const</span> <a class="code" href="structCdx.html">Cdx</a> *cdx, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *b, <span class="keywordtype">int</span> l, <a class="code" href="structKey.html">Key</a> *key );
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <span class="keyword">enum</span> { <span class="comment">/* see Metadata.txt */</span>
<a name="l01112"></a>01112         MET_OPT = 001,
<a name="l01113"></a>01113         MET_UNU = 002,
<a name="l01114"></a>01114         MET_CTP = 003,
<a name="l01115"></a>01115         MET_COL = 004,
<a name="l01116"></a>01116         MET_VER = 005,
<a name="l01117"></a>01117         MET_FLD = 006
<a name="l01118"></a>01118 };
<a name="l01119"></a>01119 
<a name="l01123"></a><a class="code" href="structDb.html">01123</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structDb.html">Db</a> {
<a name="l01124"></a>01124         <span class="keywordtype">char</span>       *nam;
<a name="l01125"></a>01125         <span class="keywordtype">char</span>       *pat;
<a name="l01126"></a>01126         <span class="keywordtype">int</span>         flg;
<a name="l01127"></a>01127         <span class="keywordtype">int</span>         mnt; <span class="comment">/* mount count */</span>
<a name="l01128"></a>01128         <span class="keyword">struct </span><a class="code" href="structDb.html">Db</a>  *nxt; <span class="comment">/* linked list */</span>
<a name="l01129"></a>01129         <span class="keyword">const</span> <a class="code" href="structFld.html">Fld</a>  *opt; <span class="comment">/* inner meta data */</span>
<a name="l01130"></a>01130         <a class="code" href="structRdx.html">Rdx</a>         rdx;
<a name="l01131"></a>01131         <a class="code" href="structQdx.html">Qdx</a>         qdx;
<a name="l01132"></a>01132 } <a class="code" href="structDb.html">Db</a>;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134 <span class="keyword">extern</span> <a class="code" href="structDb.html">Db</a> *dOpen (<span class="keyword">const</span> <span class="keywordtype">char</span> *dbname);
<a name="l01135"></a>01135 <span class="keyword">extern</span> <span class="keywordtype">void</span> dClose (<a class="code" href="structDb.html">Db</a> *db);
<a name="l01136"></a>01136 <span class="keyword">extern</span> <span class="keywordtype">void</span> dCloseAll ();
<a name="l01137"></a>01137 
<a name="l01143"></a>01143 <span class="preprocessor">#define dRead(l,db,rid) ((rid)?rRead(l,&amp;(db)-&gt;rdx,rid,0):lCpy(l,(db)-&gt;opt,0))</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span><span class="preprocessor">#define dWrite(db,r,rid) rWrite(&amp;(db)-&gt;rdx,r,rid,-1,0)</span>
<a name="l01145"></a>01145 <span class="preprocessor"></span>
<a name="l01146"></a>01146 <span class="preprocessor">#define dSet(db,key) qSet(&amp;(db)-&gt;qdx,key)</span>
<a name="l01147"></a>01147 <span class="preprocessor"></span><span class="preprocessor">#define dDel(db,key) qDel(&amp;(db)-&gt;qdx,key)</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span><span class="preprocessor">#define dLoop(db,ql) ((ql)-&gt;qdx=&amp;(db)-&gt;qdx, qLoop(ql))</span>
<a name="l01149"></a>01149 <span class="preprocessor"></span>
<a name="l01150"></a>01150 <span class="preprocessor">#define CORE_H</span>
<a name="l01151"></a>01151 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* CORE_H */</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Mar 30 14:47:13 2010 for IsisReader by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
